

null和""的区别

问题一：

null和""的区别

String s=null;

string.trim()就会抛出为空的exception

String s="";

string.trim()就不会抛,为什么?

答：

NULL代表声明了一个空对象，根本就不是一个字符串。

""代表声明了一个对象实例，这个对象实例的值是一个长度为0的空字符串。

NULL代表声明了一个空对象,对空对象做任何操作都不行的,除了=和==

""是一个字符串了,只是这个字符串里面没有内容了

String s=null;只是定义了一个句柄，也就是说你有了个引用，但是这个引用未指向任何内存空间

String s="";这个引用已经指向了一块是空字符串的内存空间，是一个实际的东东了，所以你可以对它操作，而不用担心什么了

你说数字0和没有是不是一种概念啊？？道理一样的

而且,null可以赋值给任何对象.""就不行了.

这里""和NULL绝对是两个概念

""代表一个字符串存在，它的值就是“”

NULL代表字符串根本没有实际的值，你并不知道它是什么。。。

哦,我明白了,意思就是String string = null 跟String string;是一回事儿

null是空对象 ""是空字符串

String s=null;//null是未分配堆内存空间

String a;//分配了一个内存空间,没存入任何对象

String a="";//分配了一个内存空间,存了一个字符串对象

问题二：

String s;和String s=null;和String s="a";有什么区别？

针对这三种情况，使用out.println(s);的时候，第一个会出现异常，第二个会输出null.第三个则会输出a.

这是为什么呢？这三句声明语句，各自作了什么呢？

答：

第一个只是定义了一个String类型变量s，并没有给它赋初值，在Java中，默认在使用一个变量的时候必须赋予它初值（降低风险）。

第二个和第三个都定义了String类型变量s，并赋予它初值，只不过第二个赋予的值为null（空）罢了

主要要理解的是String s; s为一个引用～～它不是对象

第一个是没有初始化的引用；

第二个为空引用；

第三个是在字符串池里写入一个字符'a',然后用s指向它。

另外，

String s="a"和String s=new String("a");是有本质上的区别的

前者是在字符串池里写入一个字符'a',然后用s指向它；

后者是在堆上创建一个内容为"a"的字符串对象。

String str="aaa"; //于栈上分配内存

String str=new String("aaa"); //于堆上分配内存

String s; 系统会自动赋值null

String s;只是给s分配一个内存空间

String s=null;是分配的空间中存储的值为空值

String s="a";这句就不用我多说了分配的空间的值为字符a

问题三：

声明了一个string a;变量

在以后的判断中，a==""和a==null有何不同?

答：

如果没有给a赋过值，a==""会导致异常。

在实际处理时，往往认为""和null代表相同的含义，即都代表无值。

此时建议用如下语法：

if(a==null || a=="")

{

}

如果a为null，就不会执行后面的判断，直接返回true。

null是用来判断引用类型是否分配了存储空间

""是针对字符串的；

string类型实际上是字符串指针，也即是一个引用类型

所以如果没有给a赋过值，a==""会导致异常

所以if(a==null || a==""){}这种写法也是正确的

问题四：

String abc=null;String abc="";String abc;三种写法有什么区别？

答：

1：创建一个空字符串对象，

2：创建一个字符串为空的字符串对象。

3：声明一个字符串对象，但并没有分配内存，而1，2已经分配了内存

对于最后一种表示,你不能if(abc==null),或者int length = abc.length();编译的时候会提示可能没有初始化.

String abc=null;

String abc="";

一般推荐使用第二种

第一种abc指向null，很多时候要判断字符串是否为空时，容易漏掉这种情况，在调用String的相关方法的时候就会出错

第二种则相对简单，String的方法都可以用，判断的时候也不会出错

1) String abc=null;

2) String abc;

3）String a="";

4) String b="";

5) String c=new String("");

6) String d=new String("");

//1)等于2），和C语言不同，JAVA为安全原因不允许一个悬挂引用，没有赋值的引用地址一律自动赋值为NULL，以防止访问到任意内存

//3)和4)中,变量a和b将会指向同一内存地址(""的地址)

//5)和6)中，变量c和d不会指向同一地址,而是两个""内容的地址,并且和a,b不同,实际上,3)和4)相当于new String("").intern().

//String类维护着一个字符串池,对于像3)和4)这样的赋值方法,String会在这个池中查找字符串是否已经在池中,如果在,就直接指向该地址,

如果不在,生成一个实例放入池中再指向那个地址,可见对于同样内容的字符串多次引用时3)4)的方法要比5)6)的方法剩内存,之所以这样做,是

因为String是一个内容不可变的量,运用的是设计模式GOF.FlyWeight

但有个关键的一点,没有人说到，这就是:

String s;在什么情况下可以等同于String s=null;而在什么情况下又不等同？！

考虑下面的代码:

//StringTest.java

public class StringTest {

static String s; //*

public static void main(String[] args) {

//String s; //**

System.out.println(s);

}

}

编译并运行上面的代码,将打印null。

可见标有*号的行是自动初始化了的(s被自动初始化为null)。

而如果把标有**号的行取消注释,代码将不能通过编译,这是因为这行定义的是本地变量,而本地变量是不会自动初始化的。

由此得出结论：

在成员变量的定义中,String s;等同于String s=null;

而在本地变量(方法变量)的定义中,String s;不等同于String s=null;,这时要使用s必须显式地赋值。

这些虽然是小知识点,但在实际应用中很重要,也很容易被一些人忽视,特此提出。

还有一点要说明的是：

只要是在方法在中定义变量都要显示赋初值，main()方法也不例外，而在方法之外编译器回自动赋初值。

